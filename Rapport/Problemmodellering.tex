\section{Modellering af Semplito og dets komponenter}
\subsection{Designklassediagram}
\label{DCD}

For at bedre overskue associationerne mellem klasserne i vores program, samt for at give et overblik over hvilke metoder klasserne skal have, har vi lavet et DCD. 

DCD'et er baseret på vores objekt- og domænemodel, se afsnit \ref{objektmodel} og \ref{domaenemodel} og er blevet opdateret løbende i projektet.
DCD'et har været med til at sikre, at kodestandarden blev overholdt.
Dertil har det gjort det nemmere at bestemme ansvaret for hver klasse.

For at holde det overskueligt har vi både lavet et samlet DCD, men også lavet mindre DCD'er, der er bundet til en bestemt use case, og derfor kun indeholder de klasser, som er relevante for use casen.

% Mangler evt. noget mere om hvordan den er blevet holdt op til programmet. 

\subsection{Pakkediagram - Lagdeling}
\label{Pakkediagram}

Ud over vores DCD lavede vi også et pakkediagram.
Pakkediagrammet er til stor hjælp når man skal finde rundt i programmet forskellige klasser og lag.
Ligesom DCD'et kan det give et overblik over hvilke klasser, der har kendskab til hinanden, men uden at vise metoderne, som kan gøre det sværere at overskue relationerne mellem de forskellige klasser.
Samtidigt viser pakkediagrammet mere omkring programmets lagdeling, da klasserne er opdelt i de lag, som vi har opdelt vores system i.

Pakkediagrammet giver os et bedre overblik over programmet som helhed, hvor DCD'et giver mulighed for at kigge nærmere på klasserne.

Både pakkediagrammet og DCD'et har været brugt i mange gode diskussioner i gruppen, i forbindelse med vores valg af softwarearkitektur.
Vores valg af lagdeling vil blive diskuteret nærmere i afsnit \ref{lagdeling}.

%Indsæt billede
%splendidum erat dum permansit
% Add more if needed or vital.

\subsection{Databasediagram(DBD)}
\label{DBD}

Vi har også opstillet et DBD, for at bedre overskue opstillingen af databasen.
Opstillingen af DBD'et er gjort med udgangspunkt i vores domænemodel og DCD.
Ved at betragte domænemodellen og diskutere hvilke domæneklasser, der vil være nødvendige at kunne tilgås for alle brugere af systemet ligegyldigt hvor og hvornår de er, har vi designet DBD'et som kan ses på figur \ref{fig:DBD}.

Diagrammet i sig selv har været til stor hjælp, især ved normalisering af vores tabeller. 

%Indsæt billede

\subsubsection{Relationel database}

Vi har valgt at bruge en relationel database; hvor alt data er repræsenteret som tupler grupperet i relationer.
Den relationelle model blev først beskrevet af Edgar F. Codd i 1969.
Vi har valgt at bruge denne type af database, da vi har mange domæneklasser, der har forskellige sammenhænge, som det kan ses på figur \ref{system:domaene}.

Hvis vi blot havde vores database som en lang liste af data ville det give problemer.
Man kan forestille sig, at PsykologNord ansætter en ny behandler, som endnu ikke har nogen aftaler.
Det ville betyde, at vi ville have en masse tomme værdier i resten af den række, hvor behandlerens informationer står.\cite{database}

I stedet deles den store tabel op i mindre tabeller, der indeholder referencer til hinanden.

\subsubsection{Normalisering af databasediagrammet}

Hvor mange forskellige tabeller skal man så lave? Til at finde ud af dette bruger man det, som Codd kalder normalformer.
Der eksistere et hav af normalformer, men i denne rapport vil der arbejdes med første, anden, tredje og Boyce-Codd normalform.

Man bruger normalisering og normalformerne til at reducere redundans og forbedre præcisionen og konsistens af dataerne i ens database.

Første normalform er opfyldt, når følgende gælder:
\begin{itemize}
    \item Alle cellerne i en tabel indeholder én værdi
    \item Alle indgange i en søjle er af samme type
    \item Hver søjle har et unikt navn
    \item Rækkefølgen af søjlerne er ligegyldig
    \item Rækkefølgen af rækkerne er ligegyldig
    \item Ingen rækker er ens
\end{itemize}

Anden normalform er opfyldt, når første normalform er opfyldt, og når det gælder, at alle ikke primærnøgle søjler er afhængig af \textit{hele} primærnøglen og ikke kun en del af primærnøglen.
Det betyder altså, at det kun er tabeller med sammensatte primærnøgler, der kan være på første normalform uden også at være på anden normalform. Hvis man har en tabel \textbf{(\underline{A}, \underline{B}, C, D, E)}, hvor \textbf{(A, B)} er en sammensat nøgle, skal det altså gælde at \textbf{C}, \textbf{D} og \textbf{E} ikke kan bestemmes af kun \textbf{A} eller kun \textbf{B}.

En tabel er på tredje normalform, hvis den er på anden normalform og der er ingen funktionelle afhængigheder i mellem ikke-nøgle søjler.
Det betyder altså, at hvis vores ovenstående eksempel skal være på tredje normalform må ingen af \textbf{C}, \textbf{D} eller \textbf{E} kunne bestemmes af \textbf{C}, \textbf{D}, \textbf{E} eller en kombination af disse.

For at opnå Boyce-Codd normalform skal tabellen være på tredje normalform, og alle determinanter skal være kandidatnøgler.
En determinant er den frie variable i en funktionel afhængighed. Har man funktionen \(f(n) = 5n^2 \), vil \(n\) være determinanten.\cite{database}


\subsubsection{Views}


\subsubsection{Stored Procedures}
%Der skal skrives mere.





